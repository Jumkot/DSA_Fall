# Лабораторная работа 1
**Самобалансирующиеся деревья поиска (красно-чёрное дерево)**

Реализовать функции для работы с красно-чёрными деревьями (red-black trees):
> struct rbtree *rbtree_add(struct rbtree *root, int key, char *value)
> 
> struct rbtree *rbtree_lookup(struct rbtree *root, int key)
> 
> struct rbtree *rbtree_delete(struct rbtree *root, int key)
> 
> struct rbtree *rbtree_min(struct rbtree *root)
> 
> struct rbtree *rbtree_max(struct rbtree *root)
> 
> void rbtree_free(struct rbtree *root)
> 
> void rbtree_print_dfs(struct rbtree *root, int level)

* Функцию rbtree_delete реализовать на основе алгоритма, описанного в [CLRS 3ed., c. 356]
* Вставить в красно-чёрное дерево ~50000 элементов, заранее отсортированных в порядке
возрастания/убывания
* Используя функцию rbtree_lookup, продемонстрировать логарифмическую зависимость высоты
дерева от количества добавленных в него узлов
* Продемонстрировать алгоритм удаления узлов из дерева
* Описать случаи, нарушающие красно-чёрные свойства (при добавлении и удалении узлов)
* Доказать утверждение о высоте красно-чёрного дерева

# Курсовая работа
**Октодерево**
В данной работе рассматривается октодерево – структура для разбиения трёхмерного пространства. Такое дерево также называют восьмеричным деревом, так как каждый его узел имеет восемь дочерних узлов. Разъяснены сфера применения алгоритма, его принципы и преимущества.
На языке C++ были реализованы сама структура октодерева и базовые для любой древовидной структуры операции:
1. Добавление конкретного узла
2. Поиск конкретного узла
3. Удаление конкретного узла
Проведена наглядная демонстрация результатов работы программы. Реализован код для проведения экспериментального исследования вычислительной сложности операций алгоритма и их сравнительный анализ.
